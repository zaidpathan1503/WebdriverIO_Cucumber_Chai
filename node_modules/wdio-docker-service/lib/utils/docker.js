'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _deepMerge = require('./deepMerge');

var _deepMerge2 = _interopRequireDefault(_deepMerge);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ping = require('./ping');

var _ping2 = _interopRequireDefault(_ping);

var _childProcess = require('./childProcess');

var _events = require('events');

var _optionsSerializer = require('./optionsSerializer');

var _optionsSerializer2 = _interopRequireDefault(_optionsSerializer);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _dockerEventsListener = require('./dockerEventsListener');

var _dockerEventsListener2 = _interopRequireDefault(_dockerEventsListener);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SPACE = ' ';
const INSPECT_DOCKER_INTERVAL = 500;
const MAX_INSPECT_ATTEMPTS = 10;
const DEFAULT_OPTIONS = {
    rm: true
};

/**
 * @class {Docker} Provides functionality to run docker container
 */
class Docker extends _events.EventEmitter {
    /**
     * @param {String} image Docker image/tag name
     * @param {Boolean} [debug] Enables logging
     * @param {Object} [options] Docker run options
     * @param {String|Object} [healthCheck] Url that verifies that service is running
     * @param {String} [command] docker command that follows image/tag name
     * @param {String} [args] docker args that follow image/tag name
     * @param {Object} logger Color logger or console
     */
    constructor(image, { debug = false, options = {}, healthCheck = {}, command, args } = {}, logger = console) {
        super();

        if (!image) {
            throw new Error('Missing required image argument');
        }

        this.args = args;
        this.cidfile = _path2.default.join(process.cwd(), `${image.replace(/\W+/g, '_')}.cid`);
        this.command = command;
        this.debug = Boolean(debug);
        this.healthCheck = healthCheck;
        this.image = image;
        this.logger = logger;
        this.process = null;
        this.dockerEventsListener = new _dockerEventsListener2.default(debug, logger);

        if (typeof healthCheck === 'string') {
            this.healthCheck = { url: healthCheck };
        }

        this.options = (0, _deepMerge2.default)({
            cidfile: this.cidfile
        }, DEFAULT_OPTIONS, options);

        const cmdChain = ['docker run'].concat((0, _optionsSerializer2.default)(this.options), [this.image]);

        if (this.command) {
            cmdChain.push(this.command);
        }

        if (this.args) {
            cmdChain.push(this.args);
        }

        this.dockerRunCommand = cmdChain.join(SPACE);
    }

    /**
     * @return {Promise}
     */
    run() {
        this.debug && this.logger.log(`Docker command: ${this.dockerRunCommand}`);
        this.dockerEventsListener.connect({
            filter: `image=${this.image}`
        });

        if (this.debug) {
            this.dockerEventsListener.once('image.pull', event => {
                this.logger.info('Pulling image:', JSON.stringify(event, null, 4));
            });
        }

        return this._removeStaleContainer().then(() => {
            return this._isImagePresent().catch(() => {
                this.logger.warn('NOTE: Pulling image for the first time. Please be patient.');
                return this._pullImage();
            });
        }).then(() => {
            this.debug && this.logger.info(`Launching docker image '${this.image}'`);
            return (0, _childProcess.runProcess)(this.dockerRunCommand);
        }).then(process => {
            this.process = process;
            this.emit('processCreated');

            if (this.debug) {
                this.process.stdout.on('data', data => {
                    this.logger.log(data);
                });

                this.process.stderr.on('data', data => {
                    this.logger.error(data);
                });

                this.dockerEventsListener.once('container.start', event => {
                    this.logger.info('Container started:', JSON.stringify(event, null, 4));
                });

                this.dockerEventsListener.once('container.stop', event => {
                    this.logger.info('Container stopped:', JSON.stringify(event, null, 4));
                });
            }

            return this._reportWhenDockerIsRunning().then(() => {
                this.debug && this.logger.info('Docker container is ready');
                return process;
            });
        }).catch(err => {
            if (err.code === 'ENOENT') {
                return _bluebird2.default.resolve();
            }

            throw err;
        });
    }

    /**
     * @return {Promise}
     */
    stop() {
        return this._removeStaleContainer().then(() => {
            if (this.process) {
                this.process.kill();
                this.process = null;
            }

            this.debug && this.logger.info('Docker container has stopped');
            this.dockerEventsListener.disconnect();
        });
    }

    /**
     * Polls for availability of application running in a docker
     * @return {Promise<any>}
     * @private
     */
    _reportWhenDockerIsRunning() {
        const {
            url,
            maxRetries = MAX_INSPECT_ATTEMPTS,
            inspectInterval = INSPECT_DOCKER_INTERVAL,
            startDelay = 0
        } = this.healthCheck;

        if (url === undefined) {
            return _bluebird2.default.resolve();
        }

        return _bluebird2.default.delay(startDelay).then(() => new _bluebird2.default((resolve, reject) => {
            let attempts = 0;
            let pollstatus = null;

            const poll = () => {
                (0, _ping2.default)(url).then(() => {
                    resolve();
                    clearTimeout(pollstatus);
                    pollstatus = null;
                }).catch(err => {
                    attempts++;
                    if (attempts >= maxRetries) {
                        clearTimeout(pollstatus);
                        pollstatus = null;
                        reject(err);
                        return;
                    }

                    pollstatus = setTimeout(poll, inspectInterval);
                });
            };

            pollstatus = setTimeout(poll, inspectInterval);
        }));
    }

    /**
     * @return {Promise}
     * @private
     */
    _isImagePresent() {
        return (0, _childProcess.runCommand)(`docker inspect ${this.image}`);
    }

    /**
     * @return {Promise}
     * @private
     */
    _pullImage() {
        return (0, _childProcess.runCommand)(`docker pull ${this.image}`);
    }

    /**
     * Removes any stale docker image
     * @return {Promise}
     * @private
     */
    _removeStaleContainer() {
        return _fsExtra2.default.readFile(this.cidfile).then(cid => {
            this.debug && this.logger.info('Shutting down running container');
            return Docker.stopContainer(cid).then(() => Docker.removeContainer(cid));
        }).catch(() => _bluebird2.default.resolve()).then(() => {
            this.debug && this.logger.info('Cleaning up CID files');
            return _fsExtra2.default.remove(this.cidfile);
        });
    }

    /**
     * @static
     * @param {String} cid Container id
     * @return {Promise}
     */
    static stopContainer(cid) {
        return (0, _childProcess.runCommand)(`docker stop ${cid}`);
    }

    /**
     * @static
     * @param {String} cid Container id
     * @return {Promise}
     */
    static removeContainer(cid) {
        return (0, _childProcess.runCommand)(`docker rm ${cid}`);
    }
}

exports.default = Docker;
//# sourceMappingURL=docker.js.map